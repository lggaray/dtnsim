//
// Generated file, do not edit! Created by nedtool 5.6 from src/dtnsim.msg.
//

#ifndef __DTNSIM_M_H
#define __DTNSIM_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
    // Include Contact and CgrRoute structures
    #include "src/node/dtn/routing/CgrRoute.h"
    
    typedef std::list<int> intList;
    typedef std::list<CgrRoute> cgrRouteList;
// }}

/**
 * Class generated from <tt>src/dtnsim.msg:15</tt> by nedtool.
 * <pre>
 * packet BundlePkt
 * {
 *     // Bundle Protocol fields (set by source node)
 *     ////////////////////////////////////////////////
 *     long bundleId;
 *     int sourceEid;
 *     int destinationEid;
 *     bool critical;
 *     simtime_t creationTimestamp;
 *     simtime_t ttl;
 *     bool returnToSender;
 *     bool custodyTransferRequested;
 * 
 *     // Source routing path
 *     CgrRoute cgrRoute;
 * 
 *     // Bundle is a report
 *     bool bundleIsCustodyReport;
 *     bool custodyAccepted;
 *     long custodyBundleId;
 * 
 *     ////////////////////////////////////////////////
 *     // Bundle meta-data (set by intermediate nodes)
 *     ////////////////////////////////////////////////
 *     int custodianEid;
 *     int senderEid;
 *     int nextHopEid;
 *     int hopCount;
 *     intList visitedNodes;
 * 
 *     // Probabilistic routing meta-data
 *     int xmitCopiesCount;
 *     double dlvConfidence;
 * 
 *     //Spray And Wait number of copies variable
 *     int bundlesCopies;
 * 
 *     //Proactive CGR Routing specific use variable 
 *     // 0 to route by delivery time
 *     // 1 to route by hops
 *     // 2 to route by hops and delivery time (making a copy)
 *     int qos;
 * 
 * }
 * </pre>
 */
class BundlePkt : public ::omnetpp::cPacket
{
  protected:
    long bundleId;
    int sourceEid;
    int destinationEid;
    bool critical;
    ::omnetpp::simtime_t creationTimestamp;
    ::omnetpp::simtime_t ttl;
    bool returnToSender;
    bool custodyTransferRequested;
    CgrRoute cgrRoute;
    bool bundleIsCustodyReport;
    bool custodyAccepted;
    long custodyBundleId;
    int custodianEid;
    int senderEid;
    int nextHopEid;
    int hopCount;
    intList visitedNodes;
    int xmitCopiesCount;
    double dlvConfidence;
    int bundlesCopies;
    int qos;

  private:
    void copy(const BundlePkt& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BundlePkt&);

  public:
    BundlePkt(const char *name=nullptr, short kind=0);
    BundlePkt(const BundlePkt& other);
    virtual ~BundlePkt();
    BundlePkt& operator=(const BundlePkt& other);
    virtual BundlePkt *dup() const override {return new BundlePkt(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual long getBundleId() const;
    virtual void setBundleId(long bundleId);
    virtual int getSourceEid() const;
    virtual void setSourceEid(int sourceEid);
    virtual int getDestinationEid() const;
    virtual void setDestinationEid(int destinationEid);
    virtual bool getCritical() const;
    virtual void setCritical(bool critical);
    virtual ::omnetpp::simtime_t getCreationTimestamp() const;
    virtual void setCreationTimestamp(::omnetpp::simtime_t creationTimestamp);
    virtual ::omnetpp::simtime_t getTtl() const;
    virtual void setTtl(::omnetpp::simtime_t ttl);
    virtual bool getReturnToSender() const;
    virtual void setReturnToSender(bool returnToSender);
    virtual bool getCustodyTransferRequested() const;
    virtual void setCustodyTransferRequested(bool custodyTransferRequested);
    virtual CgrRoute& getCgrRoute();
    virtual const CgrRoute& getCgrRoute() const {return const_cast<BundlePkt*>(this)->getCgrRoute();}
    virtual void setCgrRoute(const CgrRoute& cgrRoute);
    virtual bool getBundleIsCustodyReport() const;
    virtual void setBundleIsCustodyReport(bool bundleIsCustodyReport);
    virtual bool getCustodyAccepted() const;
    virtual void setCustodyAccepted(bool custodyAccepted);
    virtual long getCustodyBundleId() const;
    virtual void setCustodyBundleId(long custodyBundleId);
    virtual int getCustodianEid() const;
    virtual void setCustodianEid(int custodianEid);
    virtual int getSenderEid() const;
    virtual void setSenderEid(int senderEid);
    virtual int getNextHopEid() const;
    virtual void setNextHopEid(int nextHopEid);
    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);
    virtual intList& getVisitedNodes();
    virtual const intList& getVisitedNodes() const {return const_cast<BundlePkt*>(this)->getVisitedNodes();}
    virtual void setVisitedNodes(const intList& visitedNodes);
    virtual int getXmitCopiesCount() const;
    virtual void setXmitCopiesCount(int xmitCopiesCount);
    virtual double getDlvConfidence() const;
    virtual void setDlvConfidence(double dlvConfidence);
    virtual int getBundlesCopies() const;
    virtual void setBundlesCopies(int bundlesCopies);
    virtual int getQos() const;
    virtual void setQos(int qos);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BundlePkt& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BundlePkt& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/dtnsim.msg:60</tt> by nedtool.
 * <pre>
 * message TrafficGeneratorMsg
 * {
 *     int bundlesNumber;
 *     int destinationEid;
 *     int size;
 *     double ttl;
 *     double interval;
 * }
 * </pre>
 */
class TrafficGeneratorMsg : public ::omnetpp::cMessage
{
  protected:
    int bundlesNumber;
    int destinationEid;
    int size;
    double ttl;
    double interval;

  private:
    void copy(const TrafficGeneratorMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TrafficGeneratorMsg&);

  public:
    TrafficGeneratorMsg(const char *name=nullptr, short kind=0);
    TrafficGeneratorMsg(const TrafficGeneratorMsg& other);
    virtual ~TrafficGeneratorMsg();
    TrafficGeneratorMsg& operator=(const TrafficGeneratorMsg& other);
    virtual TrafficGeneratorMsg *dup() const override {return new TrafficGeneratorMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getBundlesNumber() const;
    virtual void setBundlesNumber(int bundlesNumber);
    virtual int getDestinationEid() const;
    virtual void setDestinationEid(int destinationEid);
    virtual int getSize() const;
    virtual void setSize(int size);
    virtual double getTtl() const;
    virtual void setTtl(double ttl);
    virtual double getInterval() const;
    virtual void setInterval(double interval);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TrafficGeneratorMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TrafficGeneratorMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/dtnsim.msg:68</tt> by nedtool.
 * <pre>
 * message ContactMsg
 * {
 *     int id;
 *     double dataRate;
 *     simtime_t start;
 *     simtime_t end;
 *     simtime_t duration;
 *     int sourceEid;
 *     int destinationEid;
 * }
 * </pre>
 */
class ContactMsg : public ::omnetpp::cMessage
{
  protected:
    int id;
    double dataRate;
    ::omnetpp::simtime_t start;
    ::omnetpp::simtime_t end;
    ::omnetpp::simtime_t duration;
    int sourceEid;
    int destinationEid;

  private:
    void copy(const ContactMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ContactMsg&);

  public:
    ContactMsg(const char *name=nullptr, short kind=0);
    ContactMsg(const ContactMsg& other);
    virtual ~ContactMsg();
    ContactMsg& operator=(const ContactMsg& other);
    virtual ContactMsg *dup() const override {return new ContactMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getId() const;
    virtual void setId(int id);
    virtual double getDataRate() const;
    virtual void setDataRate(double dataRate);
    virtual ::omnetpp::simtime_t getStart() const;
    virtual void setStart(::omnetpp::simtime_t start);
    virtual ::omnetpp::simtime_t getEnd() const;
    virtual void setEnd(::omnetpp::simtime_t end);
    virtual ::omnetpp::simtime_t getDuration() const;
    virtual void setDuration(::omnetpp::simtime_t duration);
    virtual int getSourceEid() const;
    virtual void setSourceEid(int sourceEid);
    virtual int getDestinationEid() const;
    virtual void setDestinationEid(int destinationEid);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ContactMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ContactMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/dtnsim.msg:78</tt> by nedtool.
 * <pre>
 * message ForwardingMsgEnd
 * {
 *     int neighborEid;
 *     int contactId;
 *     long bundleId;
 *     bool sentToDestination;
 * }
 * </pre>
 */
class ForwardingMsgEnd : public ::omnetpp::cMessage
{
  protected:
    int neighborEid;
    int contactId;
    long bundleId;
    bool sentToDestination;

  private:
    void copy(const ForwardingMsgEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ForwardingMsgEnd&);

  public:
    ForwardingMsgEnd(const char *name=nullptr, short kind=0);
    ForwardingMsgEnd(const ForwardingMsgEnd& other);
    virtual ~ForwardingMsgEnd();
    ForwardingMsgEnd& operator=(const ForwardingMsgEnd& other);
    virtual ForwardingMsgEnd *dup() const override {return new ForwardingMsgEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getNeighborEid() const;
    virtual void setNeighborEid(int neighborEid);
    virtual int getContactId() const;
    virtual void setContactId(int contactId);
    virtual long getBundleId() const;
    virtual void setBundleId(long bundleId);
    virtual bool getSentToDestination() const;
    virtual void setSentToDestination(bool sentToDestination);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ForwardingMsgEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ForwardingMsgEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/dtnsim.msg:85</tt> by nedtool.
 * <pre>
 * message ForwardingMsgStart
 * {
 *     int neighborEid;
 *     int contactId;
 * }
 * </pre>
 */
class ForwardingMsgStart : public ::omnetpp::cMessage
{
  protected:
    int neighborEid;
    int contactId;

  private:
    void copy(const ForwardingMsgStart& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ForwardingMsgStart&);

  public:
    ForwardingMsgStart(const char *name=nullptr, short kind=0);
    ForwardingMsgStart(const ForwardingMsgStart& other);
    virtual ~ForwardingMsgStart();
    ForwardingMsgStart& operator=(const ForwardingMsgStart& other);
    virtual ForwardingMsgStart *dup() const override {return new ForwardingMsgStart(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getNeighborEid() const;
    virtual void setNeighborEid(int neighborEid);
    virtual int getContactId() const;
    virtual void setContactId(int contactId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ForwardingMsgStart& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ForwardingMsgStart& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/dtnsim.msg:90</tt> by nedtool.
 * <pre>
 * message CustodyTimout
 * {
 *     int bundleId;
 * }
 * </pre>
 */
class CustodyTimout : public ::omnetpp::cMessage
{
  protected:
    int bundleId;

  private:
    void copy(const CustodyTimout& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CustodyTimout&);

  public:
    CustodyTimout(const char *name=nullptr, short kind=0);
    CustodyTimout(const CustodyTimout& other);
    virtual ~CustodyTimout();
    CustodyTimout& operator=(const CustodyTimout& other);
    virtual CustodyTimout *dup() const override {return new CustodyTimout(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getBundleId() const;
    virtual void setBundleId(int bundleId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CustodyTimout& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CustodyTimout& obj) {obj.parsimUnpack(b);}


#endif // ifndef __DTNSIM_M_H

